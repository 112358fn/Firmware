#!/usr/bin/perl

#    This file is part of fizzim
#    Copyright (C) 2007 Zimmer Design Services
#    Copyright (C) 2008 Zimmer Design Services
#    Copyright (C) 2009 Zimmer Design Services
#    Copyright (C) 2010 Zimmer Design Services
#    Copyright (C) 2010 NXP Semiconductors
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
# 

#  Although not specifically required by GPL, if you improve/modify this
#  software, please make it available to other users either by posting
#  it yourself or sending it back to ZDS (paulzimmer@zimmerdesignservices.com)
#  Consider this an ethical obligation rather than a legal one.
#

# NXP:
# This file uses a few functions of the original fizzim.pl file.
# It extracts the info from the fzm file, and writes in a format that can be parsed
# easily to create a UTimer init file.

$| = 1;  # force immediate output

# Make sure calling location is in INC path
use File::Basename;
$my_dir = &dirname($0);
$me = &basename($0);
unshift(@INC,"$my_dir");

# Figure out revision info
$scriptversion = "0.3 2010-10-19";

# Scan for -help and -version for early exit.  If found, call parser
if (join(" ",@ARGV) =~ /-h/) {
  &process_options;
  exit; # redundant - will exit anyway
}
if (join(" ",@ARGV) =~ /-vers/) {
  &process_options;
  exit; # redundant - will exit anyway
} elsif (join(" ",@ARGV) =~ /-v(\s|$)/) {
  print STDERR "Note that -v is ambiguous.  If you want version, you must use at least -vers \n";
}

# Scan for -debug parse_input before calling parser
$debug_sections{"parse_input"} = (join(" ",@ARGV) =~ /-d\S*\s+parse_input/);

# Need to fetch the be_cmd from the file before parsing inputs.
# Call the option processing now to clear out options and leave only the
# file name.  This makes "fizzim.pl foo.fzm" work as well as 
# "fizzim.pl < foo.fzm".
# Then we can parse the file, add the be_cmd options, and
# parse again.
@orig_argv = @ARGV;
&process_options;

# Parse the input.  Do this before option processing so that we can get
# be_cmd.
&set_myattributes; # sets the myattributes hash to know what to parse
&parse_input;


# Process command-line options
# Re-build @ARGV using the options from be_cmd FIRST (so actual command-line
# options will have priority)
($be_options = $globals{machine}{be_cmd}{value}) =~ s/^[^-]*//;
@ARGV = (split(/\s+/,$be_options),@orig_argv);

&process_options;

# Output is a bit messy.  To allow for -terse, output is held in a buffer 
# (pbuf) and printed at the end.  Warnings and "assertions" are held in their 
# own arrays, with indexes to match the line they follow in pbuf.
# "assertions" are comment lines, other than warnings, to be added to the
# output.
# Init printbuffer
$pbuf[0] = "";
$indent = 0;
$line = "";


# Open the output file.
if ($outputfilename eq "") {
    die "No -output specified\n";
}
open ($outfp, '>', $outputfilename) or die "Can not open file $outputfilename: $!\n" ;


# Rename hashes
%states = %state; undef %state;
%transitions = %transition; undef %transition;


# If -inst is set, create the instance and exit
if ($inst) {
  foreach $output ((keys %reg_outputs),(keys %comb_outputs)) {
    push(@lines,"${indent}.${output} (${output}),\n");
  }
  #$lines($#lines) =~ s/,//;
  print @lines;
}


#######################
# module open
#######################

&print ($indent, "# Generated by script version: $scriptversion\n");
&print ($indent, "\n");


#######################
# User include
#######################

# Handle top-of-file comments
if ($include_at_top_of_file = $globals{machine}{include_at_top_of_file}{value}) {
  &print ($indent, "# ---------- included from $include_at_top_of_file ----------\n");

  open(FILE,"<$include_at_top_of_file") or &warning($indent,"Could not open file $include_at_top_of_file specified by attribute insert_at_top_of_file");
  while (<FILE>) {
    &print ($indent, "$_");
  }

  &print ($indent, "\n# ---------- include end ----------\n\n");

}


#######################
# Inputs
#######################

# First type of input definitions:
#
# 1. Without comment
#    These inputs are true hardware inputs that are connected to the external pins (or internal muxer).

foreach $input (keys %{ $globals{inputs} }) {
  # Check for reserved words
  if (exists $reserved_words{$input}) {
    die "Cannot use reserved word \"$input\" as an input.";
  }

  # In this step ignore all input definitions with a comment
  if ($globals{inputs}{$input}{comment}) {
    next;
  }

  # Create output line
  $line = sprintf("INPUT %s","$input");

  # Remove trailing blanks
  $line =~ s/\s*$//;

  &print($indent, "$line;\n");
}
&print($indent, "\n");


#######################
# Outputs
#######################

# An output is an entry in the global transitions table with type=output.

foreach $trans (keys %{ $globals{trans} }) {

  # Ignore it if it doesn't have the type "output"
  $type = $globals{trans}{$trans}{type};
  $type =~ s/\s*$//;
  if ($type ne "output") {
    next;
  }

  # Check for reserved words
  if (exists $reserved_words{$trans}) {
    next;
  }

  # Add a preload value if one is specified in the comment field.
  my($preload) = "";
  if ($globals{trans}{$trans}{comment} eq "0") {
    $preload = " LOW";
  }
  if ($globals{trans}{$trans}{comment} eq "1") {
    $preload = " HIGH";
  }

  # Create output line
  $line = sprintf("OUTPUT %s%s", $trans, $preload);
  &print($indent, "$line;\n");
}
&print($indent, "\n");


#######################
# Globals (counter mode, ...)
#######################

# Assume split counter mode unless the "is_unified" key is set to true.
my($is_unified) = 0;
if (read_boolean($globals{machine}{is_unified}{value})) {
  $is_unified = 1;
}

# Print counter mode (SPLIT/UNIFIED)
$mode_string = "SPLIT";
if ($is_unified) {
  $mode_string = "UNIFIED";
}
&print ($indent,"MODE $mode_string;\n");

&print($indent, "\n");


#######################
# Capture registers
#######################

# A capture register is an entry in the global transitions table with type=capture.

foreach $trans (keys %{ $globals{trans} }) {

  # Ignore it if it doesn't have the type "capture"
  $type = $globals{trans}{$trans}{type};
  $type =~ s/\s*$//;
  if ($type ne "capture") {
    next;
  }

  # Check for reserved words
  if (exists $reserved_words{$trans}) {
    next;
  }

  # Add the counter selector (specified in the comment field).
  my($counter) = "";
  if ($globals{trans}{$trans}{comment} eq "L") {

    $counter = " LOW";
  }
  if ($globals{trans}{$trans}{comment} eq "H") {
    $counter = " HIGH";
  }
  if ($globals{trans}{$trans}{comment} eq "U") {
    $counter = " UNIFIED";
  }

  # Create output line
  $line = sprintf("DEFINE CAPTURE%s %s", $counter, $trans);
  &print($indent, "$line;\n");
}
&print($indent, "\n");






#######################
# Inputs (Match)
#######################

# Second type of input definitions:

# 2. With non-empty comment
#    These pseudo-inputs are definitions for match registers. They must be in the form "<block>==<identifier>".
#    <block> is one of H, L, U. <identifier> is any C variable name or literal. The form of the comment
#    is not checked here, but later on by the parser!
#


foreach $input (keys %{ $globals{inputs} }) {
  # Check for reserved words
  if (exists $reserved_words{$input}) {
    die "Cannot use reserved word \"$input\" as an input.";
  }

  # Only input definitions with non-empty comment
  if ($globals{inputs}{$input}{comment}) {
    $comment = $globals{inputs}{$input}{comment};
  } else {
    next;
  }

  # Parse the comment. It must start with "H", "L" or "U", then "==" and any C expression.
  $comment =~ s/^\s*//;                 # Remove leading blanks
  $comment =~ s/\s*$//;                 # Remove trailing blanks
  $counter = $comment;
  $counter =~ s/\s*==[^\"]*//;          # Extract counter identifier
  $expression = $comment;
  $expression =~ s/[^\"]*==\s*//;       # Extract expression

  # Create output line
  $line = sprintf("MATCH_COND %s COMPARE %s WITH {%s}", $input, $counter, $expression);

  # Remove trailing blanks
  $line =~ s/\s*$//;

  &print($indent, "$line;\n");
}
&print($indent, "\n");


#######################
# States
#######################

# Find the counter for each state
&state_assign_counter;


my($resetstate_l) = "";
my($resetstate_h) = "";
foreach $state (keys %states) {
  # Ignore the special state "L_ALWAYS/H_ALWAYS/U_ALWAYS"
  my($innerstate) = $state;
  $innerstate =~ s/^\s*[HLU]_ALWAYS//;  # added check for U_ALWAYS
  if ($innerstate eq "") {
    next;
  };


  # Check for the reset states: H_ENTRY or L_ENTRY or U_ENTRY
  $innerstate = $state;
  $innerstate =~ s/^\s*H_ENTRY//;
  if (!$innerstate) {
    if ($resetstate_h) {
      die "H counter reset state ($state) already defined (was: $resetstate_h)"; # duplicate of reset state found
    }
    $resetstate_h = $state;
  }  
  $innerstate = $state;
  $innerstate =~ s/^\s*[LU]_ENTRY//; # added check for U entry, using L as only this is defined for unified timer
  if (!$innerstate) {
    if ($resetstate_l) {
      die "L counter reset state ($state) already defined (was: $resetstate_l)"; # duplicate of reset state found
    }
    $resetstate_l = $state;
  }  

  # Get assigned counter
  $counter = "LOW";
  if ($state2counter{$state} eq H) {
    $counter = "HIGH";
  }

  # Print STATE declaration
  $line = sprintf("DEFINE STATE %s %s", $counter, $state);
  &print($indent, "$line;\n");
}
&print($indent, "\n");


# Check if the reset states are specified
if ($resetstate_l) {
  $line = sprintf("RESETSTATE LOW %s", $resetstate_l);
  &print($indent, "$line;\n");
}
if ($resetstate_h) {
  $line = sprintf("RESETSTATE HIGH %s", $resetstate_h);
  &print($indent, "$line;\n");
}
&print($indent, "\n");


#######################
# Transitions
#######################

# First step:
# All explicit transitions in the state diagram form events.
# These events are active in the start states only.
foreach $trans (keys %transitions) {
  $setclr = "";

  # Get assigned counter by looking at the assigned counter for start or end state.
  $state = "$transitions{$trans}{startState}";
  $counter = "LOW";      $condition = $transitions{$trans}{attributes}{$key}{value};

  if ($state2counter{$state} eq H) {
    $counter = "HIGH";
  }

  # Define event name before first use
  $line = sprintf("DEFINE EVENT %s %s", $counter, $trans);
  &print($indent, "$line;\n");

  # Read all corresponding keys
  foreach $key (keys %{ $transitions{$trans}{attributes} }) {
    if ($key eq "equation") {
      # The special key "equation" holds the event condition
      $condition = $transitions{$trans}{attributes}{$key}{value};
      $condition = convert_condition ($condition);
      $line = sprintf("EVENT %s MATCH %s", $trans, $condition);
      &print($indent, "$line;\n");
    } elsif ($key eq "priority") {
      # The special key "priority" defines the order in which transitions must be evaluated.
      $priority = $transitions{$trans}{attributes}{$key}{value};
      if ($priority ne "") {
        $line = sprintf("EVENT %s PRIORITY %s", $trans, $priority);
        &print($indent, "$line;\n");
      }
    } else {
      # Other keys with non-empty value specify an action
      $thissetclr = $transitions{$trans}{attributes}{$key}{value};
      if ($thissetclr ne "") {
        # Is this an IRQ definition?
        if ($key eq "IRQ") {
            $line = sprintf("EVENT %s IRQ %s", $trans, $thissetclr);
            &print($indent, "$line;\n");
        }
        # Special handling for reserved registers
        elsif (exists $reserved_words{$key}) {
          $line = sprintf("EVENT %s %s", $trans, $key);
          &print($indent, "$line;\n");
        }
        # Is this a capture definition?
		# added case insensitive check for capture and toggle
        elsif (($transitions{$trans}{attributes}{$key}{type} eq "capture") || (($transitions{$trans}{attributes}{$key}{type} eq "CAPTURE"))) { 
            $line = sprintf("EVENT %s CAPTURE (%s)", $trans, $key);
            &print($indent, "$line;\n");
        } else {
          # This is a physical output
          if ($thissetclr eq "0") {
            $line = sprintf("EVENT %s CLEARS (%s)", $trans, $key);
            &print($indent, "$line;\n");
          } elsif ($thissetclr eq "1") {
            $line = sprintf("EVENT %s SETS (%s)", $trans, $key);
            &print($indent, "$line;\n");
          } elsif (($thissetclr eq "toggle") || ($thissetclr eq "TOGGLE")) {
            $line = sprintf("EVENT %s SETS (%s)", $trans, $key);
            &print($indent, "$line;\n");
            $line = sprintf("EVENT %s CLEARS (%s)", $trans, $key);
            &print($indent, "$line;\n");
          } else {
            die "Unknown output action \"$thissetclr\" for output \"$key\" in transition $trans";
          }
        }
      }
    }
  }

  # Start and end state for this transition. If this event starts in the special state ALWAYS,
  # the event shall be independent of the state.
  $statenames = "$transitions{$trans}{startState}";
  if (($statenames eq "L_ALWAYS") || ($statenames eq "H_ALWAYS") || ($statenames eq "U_ALWAYS")) {
    $line = sprintf("EVENT %s ALLSTATES", $trans);
    &print($indent, "$line;\n");
  } else {
    $line = sprintf("EVENT %s STATE (%s)", $trans, $statenames);
    &print($indent, "$line;\n");
  }
  $statenames = "$transitions{$trans}{endState}";
  $line = sprintf("EVENT %s JUMPS (%s)", $trans, $statenames);
  &print($indent, "$line;\n");
}

&print($indent, "\n");

&print_output;

#######################################################################
# Subroutines
#######################################################################



sub parse_input {

  my %myattributes_forcompare;

  &debug("Start of parse_input\"$_\"",0,"parse_input");

  # Create local version of myattributes with substition done to enable
  # compares
  foreach $entry (keys %myattributes) {
    $entry =~ s/\*[^\*]*\*/[^\"]+/g;
    $myattributes_forcompare{$entry} = 1;
  }

  while (<>) {
    chomp;
    s/##.*$// ;# Remove comments
    s/^\s*//;  # Remove leading whitespace

    # Toss status/endstatus
    if (/^\s*<status>/) {
      until (/^\s*<\/status>/) {
        $_ = <>;
      }
      next;
    }

    # Ignore drawArea (strips this level entirely from out data
    # structures)
    next if (/drawArea/);

    # Look for endtoken first to allow elsif to handle token case
    if (($endtoken) = (/^\s*<\/(.*)>/)) {
      &debug("endtoken: $endtoken from \"$_\"",0,"parse_input");
      &debug("ptr was \"$ptr\"",0,"parse_input");
      # Found an endtoken.  If this is the array, clear the array value.
      # Otherwise, remove everything from this token to the end from ptr.
      if ($array eq $endtoken) {
        $array = "";
        $ptr = "";
      } else {
        $ptr =~ s/{\"\Q$endtoken\E\"}.*$//;
      }
      &debug("new array is \"${array}\"",0,"parse_input");
      &debug("new ptr is \"${ptr}\"",0,"parse_input");
      &debug("",0,"parse_input");
    } elsif (($token) = (/^\s*<(.*)>/)) {
      &debug("token: $token from \"$_\"",0,"parse_input");
      # Found new token.  If array is blank, this is the new array.
      # Otherwise, append to ptr.  
      if ($array eq "") {
        $array = "$token";
      } else {
        $ptr = $ptr . "{\"$token\"}";
      }
      &debug("new array is \"${array}\"",0,"parse_input");
      &debug("new ptr is \"${ptr}\"",0,"parse_input");
      &debug("",0,"parse_input");
    } else {
      $value = $_;
      &debug("value: $value from \"$_\"",0,"parse_input");
      # Found a value instead of a token.  Use array and ptr to set
      # the value using eval.
      # First, turn state name (or transition name) into index
      &debug("old ptr (in value block) is \"$ptr\"",0,"parse_input");
      if ($ptr =~ s/({\"attributes\"}).*name.*value\"}/{\"$value\"}\1/) {
        # If this already exists, it means we have a duplicate entry!
        if (exists $${array}{"$value"}{"attributes"}) {
          &error($indent,"Error - found duplicate entry for $array $value");
        }
        &debug("new ptr (in value block) is \"$ptr\"",0,"parse_input");
      } else {
        $keep = 0;
        foreach $entry (keys %myattributes_forcompare) {
          #print STDERR "Looking at myatt $entry\n";
          #print STDERR " comparing to ${array}${ptr}\n";
          if ("${array}${ptr}" =~ $entry) {
            &debug("Got match to $entry\n",0,"parse_input");
            $keep = 1;
          }
        }
        #$cmd = "\$${array}${ptr} = q{${value}};";
        $value =~ s/"/\\"/g;  # escape quotes for next line
        $value =~ s/\$/\\\$/g; # escape $ signs (in case code has $time...)

        $cmd = "\$${array}${ptr} = \"$value\";";
        if ($keep) {
          &debug("cmd is \"$cmd\"",0,"parse_input");
          eval $cmd unless (!$array);
        } else {
          &debug("skipped cmd \"$cmd\"",0,"parse_input");
        }
      }
    }
  }

  &debug("End of parse_input\"$_\"\n\n",0,"parse_input");

  # Check some random values
  #&debug("state0 vis is $states{state0}{attributes}{vis}",0,"parse_input");
  #&debug("trans0 startState is $transitions{trans0}{startState}",0,"parse_input");
  #&debug("trans0 endState is $transitions{trans0}{endState}",0,"parse_input");
}


# Interpret string as a boolean value
sub read_boolean {
  my ($value) = @_;

  if (($value eq "1") ||
      ($value eq "yes") ||
      ($value eq "YES") ||
      ($value eq "true") ||
      ($value eq "TRUE") ||
      ($value eq "y") ||
      ($value eq "Y")) {
    return 1;
  }

  return 0;
}



# Look up the name in the list of known match registers
sub is_match_register_name {
  my($name) = @_;

  # Search in the list of input definitions. An entry with a non-empty comment field is a match register!
  foreach $input (keys %{ $globals{inputs} }) {
    # Only input definitions with non-empty comment
    if ($globals{inputs}{$input}{comment}) {
      # Is this the name we are looking for?
      if ($name eq $input) {
        return 1;
      }
    }
  }
}



# Look up the name in the list of known inputs
sub is_input_name {
  my($name) = @_;

  # Search in the list of input definitions. An entry with an empty comment field is an input register!
  foreach $input (keys %{ $globals{inputs} }) {
    # Only input definitions with empty comment
    if ($globals{inputs}{$input}{comment} eq "") {
      # Is this the name we are looking for?
      if ($name eq $input) {
        return 1;
      }
    }
  }
}



# Conversion of an I/O definition
sub convert_iodef {
  my($raw) = @_;
  my($cooked);
  my($operator);

  # An I/O definition can be a name only, or a name preceeded by either '!', '+' or '-'.
  # Get this operator first.
  $operator = "HIGH";
  if ($raw =~ /!/) { $operator = "LOW";  }
  if ($raw =~ /\+/) { $operator = "RISE"; }
  if ($raw =~ /\-/) { $operator = "FALL"; }
  $raw =~ s/[!\+\-]//;  # Remove the operator

  # Is it an input or an output?
  if (is_input_name($raw)) {
    $cooked = "INPUT";
  } else {
    $cooked = "OUTPUT";
  }

  # Add name and operator
  $cooked = "$cooked ($raw) $operator";

  return $cooked;
}


# Convert a match condition into the format expected by the parser.
# This is needed because the parser format is longer than the compact format used in the state diagram.
sub convert_condition {
  my($raw) = @_;
  my($cooked);
  my($operator);
  my($matchreg);
  my($iodef);
  my($iopart);

  # Is it a combined expression (match and/or I/O)?
  if (($raw =~ /&&/) || ($raw =~ /\|\|/)) {
    # Combined expression

    # Remember the operator
    if ($raw =~ /&&/) { $operator = "AND"; }
    if ($raw =~ /\|\|/) { $operator = "OR"; }

    # Split the two parts
    $matchreg = $raw;
    $matchreg =~ s/\s*(&&|\|\|).*//;
    $iodef = $raw;
    $iodef =~ s/.*(&&|\|\|)\s*//;

    # Convert the I/O definition
    $iopart = convert_iodef($iodef);

    # Build the output
    $cooked = "$matchreg $operator $iopart";
  } else {
    # Single expression. Can be match register or an I/O.
    if (is_match_register_name ($raw)) {
      # Single match register expression
      # Simply copy the name
      $cooked = $raw;
    } else {
      # Single I/O expression
      $cooked = convert_iodef($raw);
    }
  }  

  return $cooked;
}




# For each state determine the corresponding state machine (either L or H) by following the transitions.
sub state_assign_counter {

    my($done);
    my($pass);
    my($state);
    my($trans);
    my($startnode);
    my($endnode);


    # Create a hash with all states and their corresponding counter
    foreach $state (keys %states) {
        $state2counter{$state} = "X";
    }

    # Loop until either all assignment are done or a timeout occurs.
    $done = 0;
    $pass = 100;
    while (!$done && $pass) {
        # Run through loop for a maximum number of counts only
        $pass = $pass - 1;

        $done = 1;
        # Are all states assigned now?
        foreach $state (keys %states) {
            if (($state2counter{$state} ne L) && ($state2counter{$state} ne H)) {
                $done = 0;
            }
        }

        if (!$done) {
            # States with predefined names have known counters:
            # H_ALWAYS, L_ALWAYS, H_ENTRY, L_ENTRY, U_ALWAYS, U_ENTRY
			# added U_ENTRY, U_ALWAYS for graphical consistency
            foreach $state (keys %states) {
                if (($state eq "H_ALWAYS") || ($state eq "H_ENTRY")) {
                    $state2counter{$state} = "H";
                }
                if (($state eq "L_ALWAYS") || ($state eq "L_ENTRY") || ($state eq "U_ENTRY") || ($state eq "U_ALWAYS")) {
                    $state2counter{$state} = "L"; # added checks for unified timer, placed into the L side, H not used
                }
            }

            # If one end of a transistion is already assigned, the other end belongs
            # to the same counter.
            foreach $trans (keys %transitions) {
                $startnode = "$transitions{$trans}{startState}";
                $endnode = "$transitions{$trans}{endState}";
                if ($state2counter{$startnode} ne "X") {
                    if ($state2counter{$endnode} eq "X") {
                        $state2counter{$endnode} = $state2counter{$startnode};
                    } else {
                        if ($state2counter{$endnode} ne $state2counter{$startnode}) {
                            die
"Illegal connection between L and H state machines. Check states ($startnode) and ($endnode)\n";
                        }
                    }
                }

                if ($state2counter{$endnode} ne "X") {
                    if ($state2counter{$startnode} eq "X") {
                        $state2counter{$startnode} = $state2counter{$endnode};
                    } else {
                        if ($state2counter{$endnode} ne $state2counter{$startnode}) {
                            die
"Illegal connection between L and H state machines. Check states ($startnode) and ($endnode)\n";
                        }
                    }
                }
            }
        }
    }
}




sub debug {
  my ($string,$depth,$section) = @_;
  if ($global_debug || $debug_sections{$section}) {
    print STDERR " " x $depth . "<db${section}>: $string\n";
  }
}

sub error {
  my ($indent,$string) = @_;

  # indent is ignored.  It is just there to make it easy to switch btw
  # warnings and errors.

  &print_output;
  print "\n\nError: $string - exiting\n";
  print STDERR "\n\nError: $string - exiting\n";
  exit;
}

sub warning {
  my($indent,$string) = @_;
  my($group,$number) = ();

  # Determine warning number based on string.  It would be cleaner to just
  # have the call use the number, but that makes it difficult to see what
  # the warning is when reading the code.
  if ($string =~ /No reset specified/) {$group = "R"; $number = 1;}
  elsif ($string =~ /No reset value for datapath output \S+ set in reset state \S+ - Assiging a reset value of \S+ based on default/) {$group = "R"; $number = 5;}
  # Now an error:
  #elsif ($string =~ /Specified reset signal \S+ is not an input/) {$group = "R"; $number = 6;} 

  elsif ($string =~ /Neither implied_loopback nor default_state_is_x attribute is set on state machine - defaulting to implied_loopback to avoid latches being inferred/) {$group = "I"; $number = 2;}

  elsif ($string =~ /State \S+ has multiple exit transitions, and transition \S+ has no defined priority/) {$group = "P"; $number = 3;}
  elsif ($string =~ /State \S+ has multiple exit transitions, and transition \S+ has the same priority as transition .*/) {$group = "P" ; $number = "4"}

  elsif ($string =~ /Combinational output \S+ is assigned on transitions, but has a non-default value ".+" in state \S+/) {$group = "C" ; $number = 7;}

  elsif ($string =~ /Neither implied_loopback nor default_state_is_x attribute is set on onehot state machine and there is no loopback arc - this could result in latches being inferred/) {$group = "I"; $number = 8;}

  elsif ($string =~ /Did not find any non-default values for any datapath outputs - suppressing case statement/) {$group = "D"; $number = 9;}

  elsif ($string =~ /Combinational output \S+ has no default value/) {$group = "C" ; $number = 10;}

  elsif ($string =~ /Datapath output \S+ has no default value/) {$group = "D" ; $number = 11;}

  elsif ($string =~ /Using override value from attribute/) {$group = "O" ; $number = 12;}

  # Output warning unless suppressed
  unless ($nowarns{"${group}${number}"} || $nowarns{$group}) {
    eval "\$myindent = \"$indentstring\" x $indent";
    if ($warnout eq "stdout" || $warnout eq "both") {
      # warnings are stored in an array whose indeces correspond to the
      # previous line of pbuf.  Use concat in case there are multiple warnings
      # associated with the same line.
      $warnings[$#pbuf] = $warnings[$#pbuf] . "${myindent}// Warning $group$number: $string \n";
    }
    if ($warnout eq "stderr" || $warnout eq "both") {
      print STDERR "\n\nWarning $group$number: $string \n";
    }
  }
}

sub assertion {
  my($indent,$string) = @_;

  eval "\$myindent = \"$indentstring\" x $indent";
  $assertions[$#pbuf] = $assertions[$#pbuf] . "${myindent}${string}\n";
}

sub print {
  my($indent,$string) = @_;
  my($skip,$maxlen,$thislen) = 0;
  my($tag) = "//tersetag";
  my($i,$j);
 
  $section = "terse"; # for debug
  # -terse handling
  # If you plan to follow or modify the -terse code, be sure to have an
  # ample supply of barf bags near to hand.  It is HORRIBLE.
  #
  # The basic idea is that all calls to &print go to an array (pbuf).  This
  # is done even without -terse, just to be consistent.  Warnings and
  # "comments" must go to separate arrays that parallel pbuf.  This makes
  # it easier for the tersify code to find its way around.
  #
  # When -terse is on, it looks for "end" and "endcase" (plus wire statements),
  # and starts poking around in the pbuf to try to get rid of begin/end pairs.
  # When it finds an "endcase", it backs up through pbuf to tag lines as
  # statement and non-statement, and to calculate how much indent will be
  # required to make the assignment statements line up.  It then goes back
  # forward through pbuf and makes these modifications.
  #
  # Yech!
   
  # 1) Get rid of unnecessary wire statements
  if ($terse && ($string =~ /^\s*(in|out)put wire /)) {
    ($temp = $string) =~ s/\/\/.*$//; # temp is string without any comments
    unless ($temp =~ /\[\d+:\d+\]/) { # unless temp has [n:m]..
      $string =~ s/ wire//;           # get rid of the wire statement
    }
  }
  # Ditto for logic inputs in sv
  if ($language eq "systemverilog" && $terse && ($string =~ /^\s*input logic /)) {
    ($temp = $string) =~ s/\/\/.*$//; # temp is string without any comments
    unless ($temp =~ /\[\d+:\d+\]/) { # unless temp has [n:m]..
      $string =~ s/ logic//;           # get rid of the wire statement
    }
  }

  # 2) Get rid of extra begin/end pairs
  #
  if ($terse && ($string =~ /^\s*end\s*$/))  {
    # a) If we're on an "end" line and the next-to-previous line ends in begin,
    # strip the begin and newline and set skip flag.
    # ex: 
    # if (foo) begin
    #   bar <= 0
    # end
    # or:
    # begin
    #   bar <= 0
    # end
    if (!&is_stateline($pbuf[$#pbuf - 1])
     && $pbuf[$#pbuf - 1] =~ s/begin\s*$/\1/
    ) {
      &debug("Doing step a on \"$string\"\n",0,$section);
      $skip = 1;
      # If resulting string is empty, remove it
      if ($pbuf[$#pbuf - 1] =~ /^\s*$/) {
        splice(@pbuf, $#pbuf -1, 1);
      }
      # Unindent
      eval "\$myindent = \"$indentstring\"";
      $pbuf[$#pbuf] =~ s/$myindent//;

    # b) If we're on an "end" line and the next-to-previous line looks like
    # a "IDLE:" line, strip the begin and newline and set skip flag.
    # ex: 
    # IDLE: begin
    #   bar <= 0
    # end
    } elsif (&is_stateline($pbuf[$#pbuf - 1])) {
      &debug("Doing step b on \"$string\"\n",0,$section);
      if ($pbuf[$#pbuf - 1] =~ s/(\S+\s*:)\s+begin\s*$/\1/) {
        $skip = 1;
        # Unindent
        #eval "\$myindent = \"$indentstring\"";
        #$pbuf[$#pbuf] =~ s/$myindent//;
      }

    # c) If we're on an "end" line and the next-to-previous line is "else", 
    # 2 lines up from that is "if", and
    # 1 line from that is "state:"
    # IDLE: begin	< -4
    # if (foo)		< -3
    #   bar <=1		< -2
    # else		< -1
    #   bar <= 0	<  0
    # end		< curr
    #
    # remove the begin and newline, join the lines and set skip flag
    # (lines are joined explicitly because "case" step needs all "statements"
    # on a single line).
    # Also, scoot the -1 line (else) over by the length to the ":" plus 1
    #
    # Ends up as:
    # IDLE: if (foo) bar <=1   <-2
    # else    bar <= 0         <-1	
    # end		       < curr
    } elsif ($pbuf[$#pbuf -1] =~ /else /) {
      # Look for first if and previous state
      $n = 3;
      while ($pbuf[$#pbuf - $n] =~ /else if/) {
        $n = $n+2;
      }

      if ($pbuf[$#pbuf - $n] =~ /^\s*if /
           && $pbuf[$#pbuf - $n - 1] =~ /begin\s*$/  # no comment on state begin
           && (&is_stateline($pbuf[$#pbuf - $n - 1]))
           ) {

        &debug("In step c, n is \"$n\"\n",0,$section);
        $stateline = $#pbuf - $n - 1;
        &debug("In step c, stateline is \"$stateline\"\n",0,$section);

        &debug("Doing step c on \"$string\"\n",0,$section);
        $pbuf[$stateline] =~ s/(\S+\s*:)\s+begin\s*$/\1/; # strip begin
  
        # Do the "scoot"
        $colonpos = index($pbuf[$stateline],":");
        ($temp = $pbuf[$stateline]) =~ s/^(\s*).*$/\1/;
        $startpos = length($temp);
        $scoot = $colonpos - $startpos;
        &debug("Scoot is \"$scoot\"\n",0,$section);
        for ($i = $#pbuf-1; $i > $stateline+1; $i = $i - 2) {
          &debug("Scooting line \"$pbuf[$i]\"\n",0,$section);
          $pbuf[$i] = " " x $scoot . $pbuf[$i];
        }
        
        # Remove indent on -3 and join -3 and -4 into -3
        # Might not be literally -3 and -4..., make it relative to stateline
        $pbuf[$stateline+1] =~ s/^$level4indent/ /;
        $pbuf[$stateline+1] = $pbuf[$stateline] . $pbuf[$stateline+1];
        # And snuff out -4
        &move_warnings_and_assertions($stateline,$stateline+1); # move warnings/assertions to -3
        splice(@pbuf, $stateline, 1);
        #$pbuf[$#pbuf - 4] = "";
        $skip = 1;
      }

    # d) If we're on an "end" line and their are "stacked begin/begin end/end
    # sets, like this:
    # IDLE: begin	< -?
    #   begin           < -?
    #     bar <=1	< -?
    #     bar <= 0	< -1
    #   end             <  0
    # end		< curr
    # remove the inside begin/end pair, but do not set skip flag.
    } elsif ($pbuf[$#pbuf] =~ /^\s*end/) { # previous was ALSO end
      &debug("Doing step d on \"$string\"\n",0,$section);
      # troll through the buffer looking for the previous begin
      $i = $#pbuf-1;
      while ($pbuf[$i] !~ /^[^\/]*begin/ && $pbuf[$i] !~ /^\s*end/ && $i > 0) {
        $i--
      }
      # $i is now pointing at begin (or at end or start of buffer)
      # If it is begin, then do our thing
      if ($pbuf[$i] =~ /^\s*begin/) { # MUST be a PURE begin
        if ($pbuf[$i-1] =~ /^[^\/]*begin/) { # Previous is ALSO a begin
          # Note that pure begin/ends should not have warnings, so it is
          # safe to do the snuff...
          # snuff out $i entry
          splice(@pbuf, $i, 1);
          #$pbuf[$i] = "";
          # snuff out last entry (previous end)
          splice(@pbuf, $#pbuf, 1);
          #$pbuf[$#pbuf] = "";
        }
      }

    # e) If we're on an "end" line and the next-to-previous line is "if", 
    # 1 line from that is "state:"
    # IDLE: begin	< -2
    # if (foo)		< -1
    #   bar <=1		< 0
    # end		< curr
    # remove the begin and newline, join the lines and set skip flag
    # (lines are joined explicitly because "case" step needs all "statements"
    # on a single line).
    } elsif ( $pbuf[$#pbuf -1] =~ /if /
           && $pbuf[$#pbuf -2] =~ /begin\s*$/  # no comment on state begin
           && (&is_stateline($pbuf[$#pbuf - 2]))
           ) {

      &debug("Doing step e on \"$string\"\n",0,$section);
      $pbuf[$#pbuf - 2] =~ s/(\S+\s*:)\s+begin\s*$/\1/; # strip begin

      
      # Remove indent on 2 and join -1 and -2 into -1
      $pbuf[$#pbuf-1] =~ s/^$level4indent/ /;
      $pbuf[$#pbuf-1] = $pbuf[$#pbuf-2] . $pbuf[$#pbuf-1];
      # And snuff out -2
      &move_warnings_and_assertions($#pbuf-2,$#pbuf-1); # move warnings/assertions to -1
      splice(@pbuf, $#pbuf -2, 1);
      #$pbuf[$#pbuf - 2] = "";
      $skip = 1;

    } else {
      #print $string;
      #print $pbuf[$#pbuf - 1];
    }
  }

  # Change the statename (sim code) section to put state and assignment
  # on the same line
  if ($terse && ($string =~ /$statenamevar\s+=/)) {
    &debug("Found statename line \"$string\"\n",0,$section);
    &debug("$pbuf[$#pbuf]\n",0,$section);
    chomp($pbuf[$#pbuf]);
  }

  # 3) At endcase, back up and re-format assignment lines to make them line up
  if ($terse && ($string =~ /^\s*endcase/)) {
    &debug("\nBefore 1st pass:\n",0,$section);
    &debug(join("",@pbuf),0,$section);
    #for ($i=0; $i<=$#pbuf; $i++) {
    #  print "$i : $pbuf[$i]\n";
    #}
    
    # "0th pass": Back up through buffer to the case statement and find
    # the max char location of equations.
    $max_eqpos = 0;
    $i = $#pbuf;
    while ($pbuf[$i] !~ /^\s*(unique )?case/ && $i > 0) {
      $nocomment = &nocomment($pbuf[$i]);
      if ($nocomment =~ /\s(if)|(else if)/)  {
        &debug("Found eq line \"$nocomment\"\n",0,$section);
        $eqpos = index($nocomment,"(");
        $max_eqpos = $eqpos if ($eqpos > $max_eqpos);
        &debug("eqpos is $eqpos max_eqpos is $max_eqpos\n",0,$section);
      }
      $i--;
    }
    
    # 1st pass: Back up through the buffer to the case statement and gather
    # information about the longest statement line.  Also, tag the lines as
    # statement (#) and provide their length if applicable by pre-pending
    # the tag.   This will be used and removed on the 2nd pass.
    $maxlen = 0;
    $i = $#pbuf;
    $thislen = 0;
    while ($pbuf[$i] !~ /^\s*(unique )?case/ && $i > 0) {
      &debug("\n\n1st pass line is:\n",0,$section);
      &debug("\"$pbuf[$i]\"",0,$section);
      if ($pbuf[$i] =~ /^\s*(if)|(else)|(end)|(begin)/ || &is_stateline($pbuf[$i])) {
        # "statement" lines
        &debug("\nIt's a statement line\n",0,$section);

        # make sure we don't get fooled by ( in a comment...
        $nocomment = &nocomment($pbuf[$i]);

        # Shift equations over
        if ($nocomment =~ /\(/) { # have a line with an equation
          $eqpos = index($nocomment,"(");
          $eq_shift = $max_eqpos - $eqpos;
          $eq_pad = " " x $eq_shift;
          &debug("eqpos is $eqpos eq_shift is $eq_shift eq_pad is \"$eq_pad\"\n",0,$section);
          &debug("unmodified equation line is \"$pbuf[$i]\"\n",0,$section);
          $pbuf[$i] =~ s/\(/$eq_pad(/;  # insert spaces to move equation over
          # Adjust pad, unless pad is full maxlen (full maxlen means that
          # there was a newline)
          &debug("  modified equation line is \"$pbuf[$i]\"\n",0,$section);
          # re-create nocomment line
          $nocomment = &nocomment($pbuf[$i]);
        }

        # Get length and set maxlen
        $thislen = length($nocomment);
        &debug("got a match: thislen is $thislen\n",0,$section);
        $maxlen = $thislen if ($maxlen < $thislen);

        if ($pbuf[$i] =~ /\n$/) {
          # lines with eol should just to be marked
          $pbuf[$i] =~ s/^/## /;
        } else {
          # Tag with length (will be removed on 2nd pass)
          $pbuf[$i] =~ s/^/#$thislen /;
        }

      } else {
        &debug("\nIt's an assignment line\n",0,$section);
      }
      &debug("\n1st pass modified line is:\n",0,$section);
      &debug("\"$pbuf[$i]\"",0,$section);
      $i--;
    }

    &debug("\nBefore 2nd pass:\n",0,$section);
    &debug(join("",@pbuf),0,$section);

    &debug("\nBefore 2nd pass, in detail:\n",0,$section);
    for ($j=$i+1;$j<$#pbuf;$j++) {
      &debug($pbuf[$j],0,$section)
    }
    &debug("\n**** end of detail ****\n",0,$section);

    # 2nd pass: go forward through the case section of the buffer and make the
    # appropriate mods
    $maxlen++;
    &debug("maxlen is $maxlen\n",0,$section);
    &debug("max_eqpos is $max_eqpos\n",0,$section);
    # $i is from above!
    $i++; # go to next after case statement
    while ($i <= $#pbuf) {
      &debug("\n2nd pass line is:\n",0,$section);
      &debug("\"$pbuf[$i]\"",0,$section);
      if ($pbuf[$i] =~ /^#/) { # statement line of some sort
        if ($pbuf[$i] =~ s/^#(\d+) //) { # this is a line without a begin
          $pad = " " x ($maxlen - $1); # calculate pad for later lines
        } else {
          # "begin" lines will have a nl, so space following lines over
          # by the full maxlen
          $pbuf[$i] =~ s/^## //;
          $pad = " " x $maxlen;
        }


        &debug("taglen is $1 ; pad is \"$pad\"\n",0,$section);
        &debug("modified statement line is \"$pbuf[$i]\"\n",0,$section);
      } else {
        $pbuf[$i] =~ s/^\s*/$pad/;
        &debug("modified assignment line is \n\"$pbuf[$i]\"\n",0,$section);
        &debug("last 2 lines: \n" . $pbuf[$i-1] . $pbuf[$i],0,$section);
      }
      $i++;
    }
    #$max_eqpos = 0;
  }

  #push(@pbuf,$indentstring x $indent . "$string") unless ($skip);
  # Handle indent in a way that makes regexp's work
  eval "\$myindent = \"$indentstring\" x $indent";
  $string = $myindent . $string;
  push(@pbuf,$string) unless ($skip);
  
  &debug("\npbuf is now:\n",0,$section);
  &debug(join("",@pbuf),0,$section);
  &debug("\npbuf done:\n",0,$section);
}

sub nocomment {
  my ($line) = @_;
  ($nocomment = $line) =~ s/\s*\/\/.*$//;
  $nocomment =~ s/\s*\/\*.*$//; # for /* - not sure if this is necessary
  return $nocomment;
}

sub print_output {
  # Dump print buffer and warnings
  for ($i=0; $i<=$#pbuf; $i++) {
    print $outfp $pbuf[$i];
    if ($pbuf[$i] =~ /\n/) {
      print $outfp $warnings[$i];
      print $outfp $assertions[$i];
    } else {
      # if line doesn't end in nl, append warning/assertion to next line
      $warnings[$i+1] = $warnings[$i] . $warnings[$i+1];
      $assertions[$i+1] = $assertions[$i] . $assertions[$i+1];
    }
  }
}

sub move_warnings_and_assertions {
  my ($from,$to) = @_;
  if ($warnings[$from]) { # move warning to $to
    $warnings[$to] = $warnings[$to] . $warnings[$from];
    $warnings[$from] = "";
  }
  splice(@warnings, $from, 1); # snuff out $from
  if ($assertions[$from]) { # move assertion to $to
    $assertions[$to] = $assertions[$to] . $assertions[$from];
    $assertions[$from] = "";
  }
  splice(@assertions, $from, 1); # snuff out $from
}



sub process_options {

  # Debug stuff
  &debug("orig_argv: " . join(" ",@orig_argv),0,"be_cmd");
  &debug("ARGV: " . join(" ",@ARGV),0,"be_cmd");

  use Getopt::Long;
  # Default non-null options
  $warnout = "both";
  $indentstring = "  ";
  $indexvar = "index";

  # Process options
  die unless GetOptions(
    "help" => \$help,
    "verbose!" => \$verbose,
    "debug=s" => \@debug_sections,
    "version!" => \$version,
    "inst!" => \$inst,
    "output=s" => \$outputfilename,
    );
  
  if ($help) {
    &show_help;
    exit;
  }

  if ($version) {
    print "$me version $scriptversion\n";
    exit;
  }

  # Turn debug array into a hash
  foreach $section (@debug_sections) {
    $debug_sections{$section} = 1;
  }
  
  # Turn nowarn array into a hash
  foreach $nowarn (@nowarns) {
    $nowarns{$nowarn} = 1;
  }


  # Create reserved words hash
  %reserved_words = (
    "INPUT" => 1,
    "OUTPUT" => 1,
    "RESETSTATE" => 1,
    "STATE" => 1,
    "EVENT" => 1,
    "HIGH" => 1,
    "LOW" => 1,
    "MATCH" => 1,
    "COMPARE" => 1,
    "WITH" => 1,
    "H" => 1,
    "L" => 1,
	"U" => 1, # added for unified mode
    "SETS" => 1,
    "CLEARS" => 1,
    "JUMPS" => 1,
    "STATES" => 1,
    "EVENTS" => 1,
    "INPUTS" => 1,
    "OUTPUTS" => 1,
    "ASSIGN" => 1,
    "DEFINE" => 1,
    "MODE" => 1,
    "SPLIT" => 1,
    "UNIFIED" => 1,
    "OR" => 1,
    "AND" => 1,
    "I" => 1,
    "O" => 1,
    "RISE" => 1,
    "FALL" => 1,
    "H_LIMIT" => 1,
    "L_LIMIT" => 1,
	"U_LIMIT" => 1, # added for unified mode
    "H_START" => 1,
    "L_START" => 1,
	"U_START" => 1, # added for unified mode
    "H_STOP" => 1,
    "L_STOP" => 1,
	"U_STOP" => 1, # added for unified mode
    "H_HALT" => 1,
    "L_HALT" => 1,
	"U_HALT" => 1, # added for unified mode
    "DMA0" => 1,
    "DMA1" => 1,
    "IRQ" => 1,
  );
}


sub show_help {
 print STDERR "Syntax:
  $me [options] 

  options:
  -help                 Show this help
  -verbose              Be Chatty
  -debug section        Turn on debug messages for section <section>
                        (Can be used multiple times)
  -warnout <output>     Control warning output.  <output> = stdout | stderr | both
  -nowarn <number>      Suppress warning number <number>
                        (Can be used multiple times)
  -version              Just echo version and exit
  -output               Name of output file

  Note: boolean switches accept the \"no\" syntax to turn them off 
    (So, -nosimcode turns off simcode)

  For details on recognized attributes, use \"-help -verbose\"
  \n";


  if ($verbose) {
    &set_myattributes;
    print STDERR "Recognized attributes:\n";
    foreach $entry (sort keys %myattributes) {
      $string = $myattributes{$entry};
      unless ($string =~ /^</) { # Skip entries marked with <>
        # Massage the output appearance
        #print "$entry:\n\t$string\n";
        foreach $array ("globals", "state", "transition") {
          $entry =~ s/^($array){"([^"]+)"}{/\1 > \2 > /;
        }
        #$entry =~ s/"//g;
        $entry =~ s/}{/ /g;
        $entry =~ s/[{}]//g;
        $entry =~ s/"value"/<value>/;
        $entry =~ s/"vis"/<vis>/;
        $entry =~ s/"type"/<type>/;
        $entry =~ s/ "attributes"//;
        $entry =~ s/ machine / state machine /;
        $entry =~ s/\*(\S+)\*/\$\1\$/g;
        $string =~ s/\*(\S+)\*/\$\1\$/g;
        print STDERR "$entry:\n\t$string\n\n";
      }
    }
  }
}

sub set_myattributes {
  # Cannot set based on encoding because file must be parsed to figure out
  # the encoding.  Cannot parse twice because it comes from STDIN.
  #if ($encoding eq "heros" || $encoding eq "onehot") {
    %myattributes = (
      'globals{"machine"}{"name"}{"value"}' => 'fsm module name',
      'globals{"machine"}{"clock"}{"value"}' => 'clock signal',
      'globals{"machine"}{"clock"}{"type"}' => 'clock signal type ("posedge", "negedge")',
      'globals{"machine"}{"reset_signal"}{"value"}' => 'reset signal',
      'globals{"machine"}{"reset_signal"}{"type"}' => 'reset signal type ("posedge", "negedge", "positive", "negative")',
      'globals{"machine"}{"reset_state"}{"value"}' => 'reset state',
      'globals{"machine"}{"reset_state"}{"type"}' => 'reset state type ("allzeros", "allones", "anyvalue")',
      'globals{"machine"}{"implied_loopback"}{"value"}' => 'Every state has an implied loopback (Note: overrides default_state_is_x)',
      'globals{"machine"}{"insert_at_top_of_file"}{"value"}' => 'Text to insert at the top of the file (use \n to get newline)',
      'globals{"machine"}{"insert_at_bottom_of_file"}{"value"}' => 'Text to insert at the bottom of the file (use \n to get newline)',
      'globals{"machine"}{"insert_at_bottom_of_module"}{"value"}' => 'Text to insert at the bottom of the module (after module statement) (use \n to get newline)',
      'globals{"machine"}{"nextstateout"}{"value"}' => 'Output on which to send out the nextstate vector',
      'globals{"machine"}{"include_at_top_of_file"}{"value"}' => 'File to include (read) at the top of the file (value is file name)',
      'globals{"inputs"}{"*input*"}{"value"}' => 'input signal *input*',
      'globals{"inputs"}{"*input*"}{"comment"}' => 'Comment for input signal *input*',
      'globals{"outputs"}{"*output*"}{"value"}' => 'output signal *output*',
      'globals{"outputs"}{"*output*"}{"type"}' => 'output signal type ("reg", "regdp" or "comb")',
      'globals{"outputs"}{"*output*"}{"comment"}' => 'Comment for output signal *output*',
      'globals{"machine"}{"name"}{"comment"}' => 'FSM name comment',
      'globals{"trans"}{"*output*"}{"value"}' => 'output signal *output* on transitions',
      'globals{"trans"}{"*output*"}{"type"}' => 'Type of signal *output*',
      'globals{"trans"}{"*output*"}{"comment"}' => 'comment for signal *output*',
      'globals{"machine"}{".*"}{"value"}' => 'misc (indentified by type)',
      'globals{"machine"}{".*"}{"type"}' => 'misc types',

      'state{"*state*"}{"attributes"}{"*output*"}{"value"}' => 'Value of output signal *state* (if *output* is an output)',
      'state{"*state*"}{"attributes"}{"vis"}' => '<internal - forces state to be parsed even if no outputs',
      'state{"*state*"}{"attributes"}{"comment"}' => 'Comment for state *state*',

      'transition{"*transition*"}{"attributes"}{"equation"}{"value"}' => 'Transition equation for transition *transition*',
      'transition{"*transition*"}{"attributes"}{"*output*"}{"value"}' => 'Value of output signal *output* (if *output* is an output) in transition *transition*',
      'transition{"*transition*"}{"attributes"}{"*output*"}{"type"}' => 'Type of output signal *output* (if *output* is an output, it will be "output") in transition *transition*',
      'transition{"*transition*"}{"attributes"}{"priority"}{"value"}' => 'Priority of transition *transition* relative to other transitions FROM that state',
      'transition{"*transition*"}{"startState"}' => '<Internal>',
      'transition{"*transition*"}{"endState"}' => '<Internal>',
      'transition{"*transition*"}{"attributes"}{"graycode"}{"value"}' => 'If set, transition must be gray-coded',
      'transition{"*transition*"}{"attributes"}{"graytransition"}{"value"}' => '<Internal - backward compatibility>',
      'transition{"*transition*"}{"attributes"}{"comment"}' => 'Comment for transition *transition*',
    );
  #} else {
  #  die "Can't do set_myattributes for encoding \"$encoding\"\n";
  #}
}


close ($outfp);

# when doing require or use we must return 1
1

